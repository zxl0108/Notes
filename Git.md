

![Git](images/logo.png)

## 关于版本控制

### 什么是版本控制(管理)

​	实际开发中，比如有一个功能，或一个文件，今天写了一点，明天又写了一点，后天又写了一点。每天都要更新代码。但是到第三天，发现昨天的代码写错了，所以得将代码回退到第一天的状态，这个时候就不好办了，因为第二天改动的地方太多了。

​	这个时候，就需要将每天写的代码都做一个备份，当然备份可以复制粘贴，这样的话文件就会太多了，不建议使用；版本控制软件就是对每天的代码做备份的工具。

版本控制主要解决两个问题：

- 历史记录，能够记录开发过程中的每一个版本，也能够在每个版本之间来回穿梭。
- 多人协作

### 本地版本控制系统

![1563803278509](images/1563803278509.png)

### 集中式

先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。

![central-repo](images/0-20190526233947050.jpeg)

![1563803841639](images/1563803841639.png)

集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。

集中式版本管理的代表：

- SVN（Subversion）

### 分布式

那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。

和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。

在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。

![distributed-repo](images/0-20190526234018814.jpeg)

![12](images/distributed.png)

当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。

CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。

除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。

微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。

分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！

## Git 介绍

- 分布式版本控制系统
  - 历史记录
  - 多人协同

### 安装 Git

- 下载地址：https://git-scm.com/downloads
- 安装
  - 一路next安装即可。

在命令行中输入以下命令查看 Git 是否安装成功。

```bash
$ git --version

# 如果看到类似 git version 2.21.0.windows.1 ，表示安装成功了
```

如果不知道命令在哪里输入，可以在任何位置，右键查看，右键选择菜单中是否有一个 `Git Bash Here`。

> 注：`$` 表示命令提示符，不需要输入它

### 使用Git管理项目

项目使用Git管理，但是不需要 推送 到 远程仓库。

新建一个 `项目代码` 的文件夹。首先初始化 Git。

- git init

把项目使用的html文件（manager文件夹）拷贝过来。

执行 `git add .` 和 `git commit -m '添加了案例的所有静态页面'`

使用Git：

- git add .   (表示把所有改变的文件和新增的文件添加到暂存区，此时没有历史记录)
- git commit -m '注释' （表示将暂存区的文件提交到本地仓库，这样就会有历史记录了）
- git log --oneline （查看历史记录）3f2l445
- git checkout 版本号  （切换到历史版本）
- git checkout master  （回到主版本）
- 多人开发，要先拉取，后推送

- git remote add 别名 远程仓库地址
- git push -u 别名 本地分支
- git push

### Git三种区域及工作流程

- 工作目录
  - 工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。
- 暂存区域
  - 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’'，不过一般说法还是叫暂存区域。
- Git 仓库
    - Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。

![1563844471358](images/1563844471358.png)

> 工作区新建的文件和Git没有任何关系；文件被添加到暂存区，才叫做被Git管理过
>
> 代码不能越过暂存区而直接从工作区提交到仓库区

### 使用Git管理自己的代码

- 在你写代码的文件夹，右键，选择 `Git Bash Here` ，这个写代码文件夹就是工作区
- 在弹出的黑色窗口中，执行 `git init` ，进行初始化
    - 初始化之后，会在当前目录生成一个隐藏文件 `.git`
- 然后就可以新建文件写代码了，此时文件在工作区
- 在黑色窗口中，执行 `git add 文件名称` ，表示将工作区的文件添加到暂存区
- 在黑色窗口中，执行 `git commit -m "提交日志"` ，表示将暂存区的文件提交到仓库

> 初次使用Git，会让我们配置用户的信息，配置方式如下：

```bash
# --global 会将配置项保存到用户配置
$ git config --global user.name "xxx"
$ git config --global user.email "xxx"
```

如果没有这个提示，是因为你之前已经使用过并配置过Git了。如果想恢复到初始的状态，我们可以打开Git的配置文件（C:\Users\你的用户名\\.gitconfig），将[user]信息删除调用。

使用的命令如下：

```bash
# 初始化 git 仓库
$ git init

# 将工作区的文件添加到暂存区
$ git add 文件名

# 提交暂存区到仓库区形成历史记录
$ git commit -m "提交日志"
```

## Git 基础

### 文件的状态

执行 `git status` 命令，可以查看到文件的状态

- 未跟踪
- 已暂存
- 已修改
- 已提交（没有提示）

**未跟踪（Untracked files）**，表示还没有被 Git 管理过，既没有进入过暂存区，更没有进入过仓库区。

![1563868996314](images/1563868996314.png)

**已暂存（staged）**，表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中

![1563869100350](images/1563869100350.png)

已修改（modified），文件被添加到暂存区，但是没有提交到仓库，然后在工作区对文件进行了修改。

![1563869228699](images/1563869228699.png)

已提交（committed），表示数据已经安全的保存在本地数据库中。

![1563869484112](images/1563869484112.png)

### 添加文件到暂存区

> [] 表示可选的

```bash
# 添加指定文件到暂存区
$ git add 文件名

# 以空格隔开可以一次 add 多个文件
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir] [file] [dir] [file] [file] ...

# 添加当前目录的所有文件到暂存区，包括子目录
$ git add .

```



### 提交文件到仓库

```bash
# 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区和暂存区自上次commit之后的变化，直接到仓库区
# 注意：不包括未跟踪文件，即不包含没有被GIt管理过的文件
$ git commit -a -m "提交日志"

```



### 查看状态

```bash
# 最好用的是 gitk
$ gitk

# 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 简略查看历史版本
$ git log --oneline

```

### 撤销操作

```bash
# 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit版本号] [file]

# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

```



## 分支

实际开发中，使用Git管理的代码已经上线了，已经投入使用了；但是还要增加一些功能，我们是在原有的基础上直接修改代码吗？肯定不是，原因很简单，一旦该错了，也许会造成非常大的损失；

这个时候，我们就需要为原来的代码创建一个副本，在这个副本上增加新功能，这个副本就是分支。当新功能测试后没有bug了，再将副本的代码（分支）合并到主分支上。



几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。

有人把 Git 的分支模型称为它的`‘必杀技特性’'，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。 为何 Git 的分支模型如此出众呢？ Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。

### 分支的新建与合并

你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即 `master` 分支。

`HEAD` 可以理解为一个指针，指针指向哪里，就表示当前正在这里开发。所以，`HEAD` 指向的就是当前分支。

一开始的时候，`master`分支是一条线，Git 用 `master` 指向最新的提交，再用 `HEAD` 指向 `master`，就能确定当前分支，以及当前分支的提交点：

![git-br-initial](images/0-1560036977779.png)

每次提交，`master` 分支都会向前移动一步，这样，随着你不断提交，`master` 分支的线也越来越长。

当我们创建新的分支，例如 `dev` 时，Git 新建了一个指针叫 `dev`，指向 `master` 相同的提交，再把 `HEAD` 指向 `dev`，就表示当前分支在 `dev` 上：

![git-br-create](images/0-1560036977789.png)

你看，Git创建一个分支很快，因为除了增加一个`dev`指针，改改`HEAD`的指向，工作区的文件都没有任何变化！

不过，从现在开始，对工作区的修改和提交就是针对`dev`分支了，比如新提交一次后，`dev`指针往前移动一步，而`master`指针不变：

![git-br-dev-fd](images/0-1560036977801.png)

假如我们在`dev`上的工作完成了，就可以把`dev`合并到`master`上。Git怎么合并呢？最简单的方法，就是直接把`master`指向`dev`的当前提交，就完成了合并：

![git-br-ff-merge](images/0-1560036977763.png)

所以Git合并分支也很快！就改改指针，工作区内容也不变！

合并完分支后，甚至可以删除`dev`分支。删除`dev`分支就是把`dev`指针给删掉，删掉后，我们就剩下了一条`master`分支：

![git-br-rm](images/0-1560036977771.png)

真是太神奇了，你看得出来有些提交是通过分支完成的吗？

下面开始实战。

首先，我们创建`dev`分支，然后切换到`dev`分支：

```bash
# 创建一个分支，名字叫做dev
$ git branch dev

# 切换分支命令；切换到dev分支上
$ git checkout dev

# 也可以使用下面的命令，代替上面两个命令；下面的命令表示创建并切换分支到dev上
$ git checkout -b dev

```

可以用 `git branch` 命令查看当前分支，命令如下：

```bash
$ git branch
# 会看到类似下面的结果，前面标注*的，表示当前分支
# * dev
#   master
```

`git branch` 命令会列出所有分支，当前分支前面会标一个`*`号。

然后，我们就可以在 `dev` 分支上进行开发了，比如增加或改动几个文件

然后提交

现在，`dev` 分支的工作完成，我们就可以切换回 `master` 分支：

```bash
$ git checkout master
```

我们把`dev`分支的工作成果合并到`master`分支上：

```bash
$ git merge dev
```

`git merge`命令用于合并指定分支到当前分支。

合并完成后，就可以放心地删除`dev`分支了：

```bash
$ git branch -d dev
```

删除后，查看`branch`，就只剩下`master`分支了：

```bash
$ git branch
* master
```

因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在`master`分支上工作效果是一样的，但过程更安全。

**小结：**

Git鼓励大量使用分支：

```bash
# 查看分支
git branch

# 创建分支
$ git branch <name>

# 切换分支
$ git checkout <name>

# 创建+切换分支
$ git checkout -b <name>

# 合并某分支到当前分支
$ git merge <name>

# 删除分支
$ git branch -d <name>
```



### 合并分支

#### 快进模式合并

如果 dev 分支包含 master 分支最新提交，那么当你合并 dev 到 master 的时候，会执行快进模式合并

快速模块就是直接指向最新提交

```bash
# 要把dev分支合并到master主分支上，需要先切回master
$ git checkout master

# 执行下面的命令，将dev分支合并到master上
$ git merge dev
```





#### 合并模式提交

如果两个分支都进行了新的提交，那么在合并的时候就执行合并模式，Git 会自动将两个分支的不同提交的改动尝试自动合并，如果合并的过程没有冲突，则直接进入 bi 编辑模式让你输入提交日志完成合并提交。

合并模式会生成一次新的提交记录。

合并的时候，如果出现下面的画面：

![1563873852307](images/1563873852307.png)

### 解决冲突

人生不如意之事十之八九，合并分支往往也不是一帆风顺的。

如果在合并分支的时候，产生了冲突，则需要解决冲突

如果产生冲突，会在合并代码的时候，给出提示：

![1563853287184](images/1563853287184.png)

当前显示aa.js有冲突，在代码中，会看到：

![1563874529679](images/1563874529679.png)

把写master分支和dev分支的两个程序员叫到一起，一起研究并解决冲突。比如经过两个程序员的讨论，决定两个改动都保留，则删除提示：

![1563874667997](Git.assets/1563874667997.png)

最后回到命令行窗口，执行add和commit提交即可。

![1563853529228](images/1563853529228.png)

## 远程仓库

### 简介

目前，我们的操作都是一个人开发，如果涉及到多人开发呢？大家的代码如何合并到一起呢？这个时候就需要公网上的一台服务器了，大家可以把代码提交到这台服务器上，也可以从服务器上拉取所有的代码。这个公网上的服务器就叫做远程仓库。

完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫 [GitHub](https://github.com/) 的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。

实际上，除了GitHib，还有很多第三方远程仓库托管服务：

- GitHub
- 码云（gitee）
- coding
- Gitlab
  - 一个开源的类似于 GitHub 的 Git 仓库托管服务
  - 支持自行搭建

### 创建GitHub账号

打开github.com网站，自行注册账号即可。

注册后，会给你注册的邮箱发送一个验证的邮件（这个邮件一般会当做垃圾邮件，也可能不是垃圾邮件），我们需要进入邮箱进行验证，验证通过即可使用该账号了。

### 基本使用

#### 将本地仓库放到线上

开发都是在本地开发，当做好一个功能后，我们就需要将本地代码推送到远程仓库

1. 在GitHub远程创建一个新的仓库

    ![1563854559890](images/1563854559890.png)

    填写信息并创建仓库。

    ![1563854825144](Git.assets/1563854825144.png)

2. 在本地仓库下执行命令进行推送，将本地仓库的代码推送到远程

    - 创建远程仓库的时候，先不要勾选README

    - 第1次推送：

        ```bash
        # 别名我们通常喜欢使用 origin 作为默认仓库的别名
        $ git remote add 别名 远程仓库地址
        
        # 当本地分支和远程分支名字一样的时候，可以简写只写一些
        # -u 的作用是记住本次的 push 地址和分支信息
        # 如果不加 -u，则下一次 push 的时候，还需要使用完整的命令
        $ git push -u 远程仓库地址别名 本地分支:远程分支
        
        如果要推送的本地分支和远端分支已有，可以简写为
        git push origin 分支
        ```

    - 之后有了新的历史记录的时候，直接 ：

        ```bash
        git push
        ```

#### 从线上克隆仓库

如果你到公司去，公司的项目已经在GitHub上了，我们就需要将项目文件从远程仓库克隆到本地，然后进行开发。

1. 找到远程仓库地址
2. 执行 `git clone 远程仓库地址` 命令，即可将远程仓库的代码拉取到本地



```bash
# clone 下来的仓库会自动创建一个名字叫 origin 的 remote 远端地址
# 并且自动和 origin master 建立关系
# 所以你这里可以直接 git push
git push
```

但是，如果你要推送别的分支代码，你还得：

```bash
git push -u 仓库地址别名 本地分支:远程分支
```

#### 拉取和更新

多人协作的情况下，我们会经常将其他人的写的代码拉取到自己的本地，完成代码或功能的合并工作，拉取远端的内容，执行下面的命令即可。

```bash
# 拉取远程代码到当前分支，并和本地分支合并
$ git pull
# 取回远程仓库的变化，并与本地指定分支合并
$ git pull [remote] [branch]
```



